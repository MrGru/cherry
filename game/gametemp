/*
 * add ui content
 */
struct shader *s = shader_texture_alloc();
struct render_queue *queue = render_queue_alloc(&stage->content_queue_list, s);
__game_create_ui_content(p, queue);

p->ui_projection_uniform  = shader_uniform_alloc();
shader_set_uniform(s, SHADER_TEXTURE_PROJECT, p->ui_projection_uniform);

project = mat4_new_ortho(-video_width/2,
        video_width/2, -video_height/2, video_height/2, 1, 10);
p->ui_cam = camera_alloc(mat4_new_look_at(
        0, 0, 1,
        0, 0, 0,
        0, 1, 0
));
shader_set_uniform(s, SHADER_TEXTURE_VIEW, p->ui_cam->view_uniform);
shader_uniform_update(p->ui_projection_uniform, project.m, sizeof(project));

// /*
//  * add node
//  */
// struct ui_sprite_param ui_param;
// ui_param.texcoord[0]    = vec2((float[2]){0, 0});
// ui_param.texcoord[1]    = vec2((float[2]){0, 1});
// ui_param.texcoord[2]    = vec2((float[2]){1, 1});
// ui_param.texcoord[3]    = vec2((float[2]){0, 0});
// ui_param.texcoord[4]    = vec2((float[2]){1, 0});
// ui_param.texcoord[5]    = vec2((float[2]){1, 1});
// ui_param.texid          = 1;
// ui_param.size           = vec3((float[3]){620 * 2, 372 * 2, 0});
// struct node_tree *nt1 = game_ui_sprite_alloc(p, &ui_param);
//
// ui_param.texcoord[0]    = vec2((float[2]){0, 0});
// ui_param.texcoord[1]    = vec2((float[2]){0, 1});
// ui_param.texcoord[2]    = vec2((float[2]){1, 1});
// ui_param.texcoord[3]    = vec2((float[2]){0, 0});
// ui_param.texcoord[4]    = vec2((float[2]){1, 0});
// ui_param.texcoord[5]    = vec2((float[2]){1, 1});
// ui_param.texid          = 0;
// ui_param.size           = vec3((float[3]){310, 419, 0});
// struct node_tree *nt2 = game_ui_sprite_alloc(p, &ui_param);
//
// ui_param.texcoord[0]    = vec2((float[2]){0, 0});
// ui_param.texcoord[1]    = vec2((float[2]){0, 1});
// ui_param.texcoord[2]    = vec2((float[2]){1, 1});
// ui_param.texcoord[3]    = vec2((float[2]){0, 0});
// ui_param.texcoord[4]    = vec2((float[2]){1, 0});
// ui_param.texcoord[5]    = vec2((float[2]){1, 1});
// ui_param.texid          = 0;
// ui_param.size           = vec3((float[3]){310, 419, 0});
// struct node_tree *nt3 = game_ui_sprite_alloc(p, &ui_param);
//
// node_tree_add_node_tree(nt1, nt3);
// node_tree_add_node_tree(nt1, nt2);
// node_swap(node_tree_get_node(nt2), node_tree_get_node(nt3));
//
// node_tree_set_position(nt3, vec3((float[3]){100, 0, 0}));
// node_tree_set_position(nt2, vec3((float[3]){50, -50, 0}));
// node_tree_set_position(nt1, vec3((float[3]){0, 0, 0}));
//
// p->ui_root = nt1;
//
// /* recalculate color tree */
// union vec4 v = vec4((float[4]){1, 1, 1, 1});
// branch_color_traverse(node_tree_get_branch_color(p->ui_root), v);
//
// /* recalculate z order  */
// float z = 0;
// branch_z_traverse(node_tree_get_branch_z(p->ui_root), &z);

render_content_set_texture(p->ui_content, 1, texture_alloc_file("res/images/wolf.jpg"));
render_content_set_texture(p->ui_content, 0, texture_alloc_file("res/images/girl.png"));

--------------------------------------------------------------------------------------

static inline void __game_resize_ui_content(struct game *p)
{
        union mat4 project = mat4_new_ortho(-video_width/2,
                video_width/2, -video_height/2, video_height/2, 1, 10);
        shader_uniform_update(p->ui_projection_uniform, project.m, sizeof(project));
}

------------------------------------------------------------------------------------------

list_while_not_singular(head, &p->node_tree_list) {
        struct node_tree *nt = (struct node_tree *)
                ((void *)head - offsetof(struct node_tree, life_head));
        node_tree_free(nt);
}
-----------------------------------------------------------------------------------------
if(p->update_queue) {
        branch_transform_queue_free(p->update_queue);
}
p->update_queue = branch_transform_queue_alloc();
---------------------------------------------------------------------------------------
list_while_not_singular(head, &p->node_tree_list) {
        struct node_tree *nt = (struct node_tree *)
                ((void *)head - offsetof(struct node_tree, life_head));
        node_tree_free(nt);
}
------------------------------------------------------------------------------------
branch_transform_queue_free(p->update_queue);
camera_free(p->ui_cam);
---------------------------------------------------------------------------------------------
/*
 * create ui content
 */
static inline void __game_create_ui_content(struct game *p, struct render_queue *queue)
{
        struct array *buffers[BUFFERS];
        u32 buffer_size = 900;
        i16 i;
        for_i(i, BUFFERS) {
                buffers[i] = array_alloc(sizeof(struct device_buffer *), ORDERED);
                array_push(buffers[i], &(struct device_buffer *){
                        buffer_quad_alloc(BUFFER_DEVICE)
                });
                array_push(buffers[i], &(struct device_buffer *){
                        buffer_z_alloc(buffer_size, BUFFER_DEVICE)
                });
                array_push(buffers[i], &(struct device_buffer *){
                        buffer_transform_alloc(buffer_size, BUFFER_PINNED)});
                array_push(buffers[i], &(struct device_buffer *){
                        buffer_color_alloc(buffer_size, BUFFER_DEVICE)
                });
                array_push(buffers[i], &(struct device_buffer *){
                        buffer_texid_alloc(buffer_size, BUFFER_DEVICE)
                });
                u8 j;
                for_i(j, 3) {
                        array_push(buffers[i], &(struct device_buffer *){
                                buffer_texcoord_alloc(buffer_size, BUFFER_DEVICE)
                        });
                }
                for_i(j, 3) {
                        array_push(buffers[i], &(struct device_buffer *){
                                buffer_vertex_alloc(buffer_size, BUFFER_DEVICE)
                        });
                }
        }

        struct render_content *content = render_content_alloc(queue, buffers, 6, buffer_size, 1);
        content->depth_test = 1;
        for_i(i, BUFFERS) {
                array_free(buffers[i]);
        }
        p->ui_content = content;
}

struct node_tree *__game_ui_sprite_alloc(struct game *p, struct ui_sprite_param *param)
{
        struct node_tree *n = node_tree_alloc(node_alloc(p->ui_content));
        node_tree_set_branch_z(n, branch_z_alloc(1));
        node_tree_set_branch_transform(n, branch_transform_alloc(2, p->update_queue));
        node_tree_set_branch_color(n, branch_color_alloc(3));
        node_tree_set_twig_texid(n, twig_texid_alloc(4));
        u8 cbid[3] = {5, 6, 7};
        node_tree_set_twig_texcoord(n, twig_texcoord_alloc(cbid));
        u8 vbid[3] = {8, 9, 10};
        node_tree_set_twig_vertex(n, twig_vertex_alloc(vbid));
        list_add_tail(&n->life_head, &p->node_tree_list);

        /*
         * we must fill all buffers datas that node reserved
         */
        /* fill texcoord buffer */
        u8 i;
        for_i(i, 6) {
                node_tree_set_texcoord(n, i, param->texcoord[i], i == 5);
        }
        /* fill vertex buffer */
        node_tree_set_vertex(n, 0, vec2((float[2]){-0.5,  0.5}), 0);
        node_tree_set_vertex(n, 1, vec2((float[2]){-0.5, -0.5}), 0);
        node_tree_set_vertex(n, 2, vec2((float[2]){ 0.5, -0.5}), 0);
        node_tree_set_vertex(n, 3, vec2((float[2]){-0.5,  0.5}), 0);
        node_tree_set_vertex(n, 4, vec2((float[2]){ 0.5,  0.5}), 0);
        node_tree_set_vertex(n, 5, vec2((float[2]){ 0.5, -0.5}), 1);
        /* fill texid buffer */
        node_tree_set_texid(n, param->texid);
        /* fill transform buffer */
        node_tree_set_size(n, param->size);
        node_tree_set_position(n, vec3((float[3]){0, 0, 0}));
        /* fill color buffer */
        node_tree_set_color(n, (union vec4){1, 1, 1, 1});
        return n;

}
-----------------------------------------------------------------------------------------------
struct node_3d_color *n1 = game_empty_node_alloc(p);
union vec4 color[6] = {
        (union vec4){255 / 255.0f, 0 / 255.0f, 55 / 255.0f, 1}, //RED
        (union vec4){0 / 255.0f, 120 / 255.0f, 255 / 255.0f, 1}, //BLUE
        (union vec4){72 / 255.0f, 255 / 255.0f, 0 / 255.0f, 1}, //GREEN
        (union vec4){255 / 255.0f, 255 / 255.0f, 0 / 255.0f, 1}, //YELLOW
        (union vec4){182 / 255.0f, 0 / 255.0f, 255 / 255.0f, 1}, //PURPLE
        (union vec4){255 / 255.0f, 86 / 255.0f, 0 / 255.0f, 1}, //ORANGE
};
---------------------------------------------------------------------
// if(!test_node) {
//         test_node = n2;
// }
// if(i == 4 && j == 0) {
//         action_key_init(&test_key);
//         test_key.transform = node_3d_color_get_branch_transform(n2);
//
//         struct rotation_vector *rv = rotation_vector_alloc();
//         rv->rad_vec3 = (union vec4){0, 1, 0, 0};
//         struct action *a = action_parallel(
//                 action_sequence(
//                         action_alloc_gravity(&rv->rad_vec3,
//                                 0, 4, &(union vec4){
//                                         rv->rad_vec3.x + DEG_TO_RAD(90),
//                                         rv->rad_vec3.y,
//                                         rv->rad_vec3.z,
//                                         rv->rad_vec3.w}, NULL),
//
//                         action_parallel(
//                                 action_alloc(&test_key.transform->position_expanded,
//                                         (union vec4){0, 5, 0, 0},
//                                         0.2f, EASE_QUADRATIC_IN_OUT, 0),
//                                 action_alloc(&rv->rad_vec3,
//                                         (union vec4){DEG_TO_RAD(-5), 0, 0, 0},
//                                         0.2f, EASE_QUADRATIC_IN_OUT, 0),
//                                 NULL
//                         ),
//                         action_parallel(
//                                 action_alloc(&test_key.transform->position_expanded,
//                                         (union vec4){0, -5, 0, 0},
//                                         0.2f, EASE_QUADRATIC_IN_OUT, 0),
//                                 action_alloc(&rv->rad_vec3,
//                                         (union vec4){DEG_TO_RAD(5), 0, 0, 0},
//                                         0.2f, EASE_QUADRATIC_IN_OUT, 0),
//                                 NULL
//                         ),
//                         NULL
//                 ),
//                 action_alloc_gravity(&test_key.transform->position_expanded,
//                         0, 500, &(union vec4){
//                                 test_key.transform->position_expanded.x,
//                                 test_key.transform->position_expanded.y - 200,
//                                 test_key.transform->position_expanded.z,
//                                 0}, NULL),
//                 NULL
//         );
//         list_add_tail(&a->user_head, &rv->action);
//         list_add_tail(&rv->head, &test_key.transform->anim_rotations);
//         action_key_add_action(&test_key, a);
//         action_manager_add_key(p->action_manager, &test_key);
// }
// if(i == 5 && j == 0) {
//         action_key_init(&test_key_2);
//         test_key_2.transform = node_3d_color_get_branch_transform(n2);
//
//         struct rotation_vector *rv = rotation_vector_alloc();
//         rv->rad_vec3 = (union vec4){0, 1, 0, 0};
//         int path = 3;
//         struct action *a = action_parallel(
//                 action_sequence(
//                         action_alloc_gravity(&rv->rad_vec3,
//                                 0, 4, &(union vec4){
//                                         rv->rad_vec3.x + DEG_TO_RAD(90 * path),
//                                         rv->rad_vec3.y,
//                                         rv->rad_vec3.z,
//                                         rv->rad_vec3.w}, NULL),
//
//                         action_parallel(
//                                 action_alloc(&test_key_2.transform->position_expanded,
//                                         (union vec4){0, 5, 0, 0},
//                                         0.2f, EASE_QUADRATIC_IN_OUT, 0),
//                                 action_alloc(&rv->rad_vec3,
//                                         (union vec4){DEG_TO_RAD(-5), 0, 0, 0},
//                                         0.2f, EASE_QUADRATIC_IN_OUT, 0),
//                                 NULL
//                         ),
//                         action_parallel(
//                                 action_alloc(&test_key_2.transform->position_expanded,
//                                         (union vec4){0, -5, 0, 0},
//                                         0.2f, EASE_QUADRATIC_IN_OUT, 0),
//                                 action_alloc(&rv->rad_vec3,
//                                         (union vec4){DEG_TO_RAD(5), 0, 0, 0},
//                                         0.2f, EASE_QUADRATIC_IN_OUT, 0),
//                                 NULL
//                         ),
//                         NULL
//                 ),
//                 action_alloc_gravity(&test_key_2.transform->position_expanded,
//                         0, 500,
//                                 &(union vec4){
//                                 test_key_2.transform->position_expanded.x,
//                                 test_key_2.transform->position_expanded.y - 200 * path,
//                                 test_key_2.transform->position_expanded.z,
//                                 0}, NULL),
//                 NULL
//         );
//         list_add_tail(&a->user_head, &rv->action);
//         list_add_tail(&rv->head, &test_key_2.transform->anim_rotations);
//         action_key_add_action(&test_key_2, a);
//         action_manager_add_key(p->action_manager, &test_key_2);
// }
